{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rubrik GraphQL API GraphQL is an API query language that allows you to retrieve just the data you need. GraphQL eliminates the common experience of an API call returning either too much or not enough data. GraphQL queries are defined in terms of types and fields. Rather than using various endpoints identified by path-based URIs and HTTP verbs, GraphQL uses a single endpoint backed by a schema that specifies how to retrieve and modify application data based on the relationship between the types and fields. You can use GraphQL queries to retrieve data, and mutations to modify data. A GraphQL query is a request to retrieve specific fields of an object type, and a GraphQL mutation is a request to modify specific fields of an object type. The GraphQL runtime engine validates the incoming queries and mutations against the schema and fulfils the valid requests. Every GraphQL service has a Query type, and may also have a Mutation type. The Query and Mutation types are special object types in the schema, as they serve as entry points to the API. GraphQL query type type Query { # Retrieves the user that is currently logged-in currentUser: User! # Retrieves the user with the specified user ID user(userId: UUID!): User! } In the above example, the Query object type has two fields: currentUser and user . This implies that the above schema supports the following types of requests: Request for the details of the currently logged-in user. Request for the details of any other user identified by the userId argument. A GraphQL query with either of these fields returns an object of type User : type User { # User ID userID: UUID! # User name email: String! # Roles that the user has roles: [String!]! } Based on the definition of the User object type, you can define the fields to be selected from the User object that is returned by the query. The following example provides a sample query and response based on the above schema definition. Sample GraphQL query Sample response query { currentUser { email roles { name } } } { \"data\": { \"currentUser\": { \"email\": \"happy.user@rubrik.com\", \"roles\": [ { \"name\": \"Administrator\", } ], } }, } More information on GraphQL queries and mutations available on graphql.org .","title":"Home"},{"location":"#rubrik-graphql-api","text":"GraphQL is an API query language that allows you to retrieve just the data you need. GraphQL eliminates the common experience of an API call returning either too much or not enough data. GraphQL queries are defined in terms of types and fields. Rather than using various endpoints identified by path-based URIs and HTTP verbs, GraphQL uses a single endpoint backed by a schema that specifies how to retrieve and modify application data based on the relationship between the types and fields. You can use GraphQL queries to retrieve data, and mutations to modify data. A GraphQL query is a request to retrieve specific fields of an object type, and a GraphQL mutation is a request to modify specific fields of an object type. The GraphQL runtime engine validates the incoming queries and mutations against the schema and fulfils the valid requests. Every GraphQL service has a Query type, and may also have a Mutation type. The Query and Mutation types are special object types in the schema, as they serve as entry points to the API.","title":"Rubrik GraphQL API"},{"location":"#graphql-query-type","text":"type Query { # Retrieves the user that is currently logged-in currentUser: User! # Retrieves the user with the specified user ID user(userId: UUID!): User! } In the above example, the Query object type has two fields: currentUser and user . This implies that the above schema supports the following types of requests: Request for the details of the currently logged-in user. Request for the details of any other user identified by the userId argument. A GraphQL query with either of these fields returns an object of type User : type User { # User ID userID: UUID! # User name email: String! # Roles that the user has roles: [String!]! } Based on the definition of the User object type, you can define the fields to be selected from the User object that is returned by the query. The following example provides a sample query and response based on the above schema definition. Sample GraphQL query Sample response query { currentUser { email roles { name } } } { \"data\": { \"currentUser\": { \"email\": \"happy.user@rubrik.com\", \"roles\": [ { \"name\": \"Administrator\", } ], } }, } More information on GraphQL queries and mutations available on graphql.org .","title":"GraphQL query type"},{"location":"api/auth/","text":"Authentication Service Accounts A service account represents an application that needs authentication and authorization to invoke Rubrik APIs, as opposed to a user account that represents an individual user. Service accounts use a client secret to authenticate to an authorization server and obtain an access token to invoke the Rubrik APIs. Similar to user accounts, Rubrik allows assigning roles to the service accounts to enable role-based access control. But contrary to user accounts, service accounts cannot be used to access the Rubrik web UI. Security Service accounts enable client applications and other services to invoke the Rubrik APIs securely. When creating a service account, the authorization server assigns a unique client ID and client secret to the account. The combination of client ID and client secret is known as client credentials. The client credentials are known only to the client that is represented by the service account and the authorization server that grants the credentials to the service account. The client application authenticates to the authorization server using the client credentials and obtains an access token to authenticate to the Rubrik API server and access the protected resources. Guidelines Consider the following best practices when using service accounts: One service account should represent only one client application. The role assigned to the service account should be the one with least number of privileges that would be sufficient for the client application being represented by the service account to access the Rubrik APIs. The client credentials must be saved when they are first created as Rubrik does not provide an option to display them again. The client secret must be treated like a password and stored in a secure location. Usage Add a service account Log in to the Rubrik web UI. Click the gear icon and select User Management . The User Management page appears, with the Users tab selected. Click Service Accounts . The Service Accounts page appears. Click Add Service Account . The Service Account Details page appears. In Name , type a service account name. Optional: In Description , type a service account description. Click Next . The Roles page appears, displaying a list of available roles. Select the roles to be assigned to the service account. Click Add . Rubrik displays the Client ID, Client Secret, and the Access Token URI to be used by the client application that owns the service account. Copy the client credentials and the access token URI and click Done . Alternatively, click Download As JSON to download a file containing the client credentials and the access token URI in the JSON format. Obtain an access token In terminal, run the following command: curl --request POST --header \"Content-Type: application/json\" \\ --data '{\"client_id\": \"$client_id\", \"client_secret\": \"$client_secret\"}' \\ $access_token_uri For example, the following command uses sample values for the variables: curl --request POST --header \"Content-Type: application/json\" \\ --data '{\"client_id\": \"client|EKy4bNDSGJfXbJZsJS2dQ5fiaeEoj1zu\", \"client_secret\": \"iNGp5X14xvD16XKwiiEqEAMAF6RxOucQIhTv9DjVC5U7BorvS5LZSEPFBhjQvo2\"}' \\ https://$account.my.rubrik-lab.com/api/client_token The authorization server responds with an encoded access token. Client applications use the access token to invoke Rubrik APIs. Using the access token Run the following command to make sure your token works correctly: QUERY='{ \"query\": \"query { currentUser { email roles { name } } }\" }' curl -X POST https://$account.my.rubrik-lab.com/api/graphql \\ --header \"Authorization: Bearer $access_token\" \\ --header \"Content-type: application/json\" \\ --data \"$(echo $QUERY)\"","title":"Authentication"},{"location":"api/auth/#authentication","text":"","title":"Authentication"},{"location":"api/auth/#service-accounts","text":"A service account represents an application that needs authentication and authorization to invoke Rubrik APIs, as opposed to a user account that represents an individual user. Service accounts use a client secret to authenticate to an authorization server and obtain an access token to invoke the Rubrik APIs. Similar to user accounts, Rubrik allows assigning roles to the service accounts to enable role-based access control. But contrary to user accounts, service accounts cannot be used to access the Rubrik web UI.","title":"Service Accounts"},{"location":"api/auth/#security","text":"Service accounts enable client applications and other services to invoke the Rubrik APIs securely. When creating a service account, the authorization server assigns a unique client ID and client secret to the account. The combination of client ID and client secret is known as client credentials. The client credentials are known only to the client that is represented by the service account and the authorization server that grants the credentials to the service account. The client application authenticates to the authorization server using the client credentials and obtains an access token to authenticate to the Rubrik API server and access the protected resources.","title":"Security"},{"location":"api/auth/#guidelines","text":"Consider the following best practices when using service accounts: One service account should represent only one client application. The role assigned to the service account should be the one with least number of privileges that would be sufficient for the client application being represented by the service account to access the Rubrik APIs. The client credentials must be saved when they are first created as Rubrik does not provide an option to display them again. The client secret must be treated like a password and stored in a secure location.","title":"Guidelines"},{"location":"api/auth/#usage","text":"","title":"Usage"},{"location":"api/auth/#add-a-service-account","text":"Log in to the Rubrik web UI. Click the gear icon and select User Management . The User Management page appears, with the Users tab selected. Click Service Accounts . The Service Accounts page appears. Click Add Service Account . The Service Account Details page appears. In Name , type a service account name. Optional: In Description , type a service account description. Click Next . The Roles page appears, displaying a list of available roles. Select the roles to be assigned to the service account. Click Add . Rubrik displays the Client ID, Client Secret, and the Access Token URI to be used by the client application that owns the service account. Copy the client credentials and the access token URI and click Done . Alternatively, click Download As JSON to download a file containing the client credentials and the access token URI in the JSON format.","title":"Add a service account"},{"location":"api/auth/#obtain-an-access-token","text":"In terminal, run the following command: curl --request POST --header \"Content-Type: application/json\" \\ --data '{\"client_id\": \"$client_id\", \"client_secret\": \"$client_secret\"}' \\ $access_token_uri For example, the following command uses sample values for the variables: curl --request POST --header \"Content-Type: application/json\" \\ --data '{\"client_id\": \"client|EKy4bNDSGJfXbJZsJS2dQ5fiaeEoj1zu\", \"client_secret\": \"iNGp5X14xvD16XKwiiEqEAMAF6RxOucQIhTv9DjVC5U7BorvS5LZSEPFBhjQvo2\"}' \\ https://$account.my.rubrik-lab.com/api/client_token The authorization server responds with an encoded access token. Client applications use the access token to invoke Rubrik APIs.","title":"Obtain an access token"},{"location":"api/auth/#using-the-access-token","text":"Run the following command to make sure your token works correctly: QUERY='{ \"query\": \"query { currentUser { email roles { name } } }\" }' curl -X POST https://$account.my.rubrik-lab.com/api/graphql \\ --header \"Authorization: Bearer $access_token\" \\ --header \"Content-type: application/json\" \\ --data \"$(echo $QUERY)\"","title":"Using the access token"},{"location":"api/errors/","text":"Errors When something goes wrong with an API request, the server returns an error. The HTTP response header includes the error code, and the response body contains the error message. Processing of the query may fail at two separate stages: The query is malformed and cannot be properly parsed or validated. The query is well-formed, but execution of the query yields an error. Successful query The following query fetches the email address of the current user: QUERY='{ \"query\": \"query { currentUser { email } }\" }' curl -X POST https://${account}.my.rubrik-lab.com/api/graphql \\ --header \"authorization: Bearer ${access_token}\" \\ --header \"content-type: application/json\" \\ --data \"$(echo $QUERY)\" The response is a JSON object where the data field contains the response data: { \"data\" : { \"currentUser\" : { \"email\" : \"happy.user@rubrik.com\" } } } Malformed query Following is an example of a malformed query, where the name of the email field is misspelled as eamil . { \"query\": \"query { currentUser { eamil } }\" } Repeat the curl command with this input query. The response header contains the 400 error code, indicating a bad request. The body of the response looks as follows: { \"code\" : 400, \"message\" : \"[QueryAnalysisError] [UserManagement Team] Encountered Client error (400) executing query with operations: [] and variables {}. Error: Query does not pass validation. Violations:\\n\\nCannot query field 'eamil' on type 'User'. Did you mean 'email'? (line 1, column 23):\\nquery { currentUser { eamil } }\\n ^\", \"traceSpan\" : { ... }, \"uri\" : \"/api/graphql\" } Where code is the HTTP status code. HTTP error codes ranging from 400-499 indicate client-side errors, while the HTTP error codes ranging from 500-599 are server-side errors. More information on error codes and their meaning is available at httpstatuses.com . message field contains a human-readable explanation of the issue the query has encountered. Erroneous query A query is erroneous if it cannot be successfully completed by the server, due to either the server malfunction or a client-side error. For example, a query that looks up a non-existing object qualifies as erroneous. The following query is looking for the status of an awsNativeAccount object whose Rubrik ID is the value indicated by the awsNativeAccountRubrikId argument. In this example, the Rubrik ID is a randomly generated UUID that does not represent a valid AWS Native account. { \"query\": \"query { awsNativeAccount( awsNativeAccountRubrikId: \\\"7f86b446-dfee-44c5-9a1e-52a7b92b0ab3\\\", awsNativeProtectionFeature: EC2) { status } }\" } The Rubrik API server responds with an HTTP status code of 200 OK. The response body looks as follows: { \"data\" : null, \"errors\" : [ { \"extensions\" : { \"code\" : 403, \"trace\" : { ... } }, \"locations\" : [ { \"column\" : 9, \"line\" : 1 } ], \"message\" : \"Objects are not authorized\", \"path\" : [ \"awsNativeAccount\" ] } ] } Where: \"data\" : null indicates that the actual response is absent. (The data field contains the actual response body as seen when issuing a successful query.) \"errors\" contains a list of errors that occurred during the processing of the query. \"errors.extensions.code\" is the HTTP error code. \"errors.extensions.message\" is a human-readable error message. Summary To summarize, the following algorithm can be used when establishing whether a query is successful: If the HTTP error code is equal to or greater than 400, the query failed. If errors field in response JSON is populated, the query failed. Otherwise, the query is successful, and its results are in data field.","title":"Errors"},{"location":"api/errors/#errors","text":"When something goes wrong with an API request, the server returns an error. The HTTP response header includes the error code, and the response body contains the error message. Processing of the query may fail at two separate stages: The query is malformed and cannot be properly parsed or validated. The query is well-formed, but execution of the query yields an error.","title":"Errors"},{"location":"api/errors/#successful-query","text":"The following query fetches the email address of the current user: QUERY='{ \"query\": \"query { currentUser { email } }\" }' curl -X POST https://${account}.my.rubrik-lab.com/api/graphql \\ --header \"authorization: Bearer ${access_token}\" \\ --header \"content-type: application/json\" \\ --data \"$(echo $QUERY)\" The response is a JSON object where the data field contains the response data: { \"data\" : { \"currentUser\" : { \"email\" : \"happy.user@rubrik.com\" } } }","title":"Successful query"},{"location":"api/errors/#malformed-query","text":"Following is an example of a malformed query, where the name of the email field is misspelled as eamil . { \"query\": \"query { currentUser { eamil } }\" } Repeat the curl command with this input query. The response header contains the 400 error code, indicating a bad request. The body of the response looks as follows: { \"code\" : 400, \"message\" : \"[QueryAnalysisError] [UserManagement Team] Encountered Client error (400) executing query with operations: [] and variables {}. Error: Query does not pass validation. Violations:\\n\\nCannot query field 'eamil' on type 'User'. Did you mean 'email'? (line 1, column 23):\\nquery { currentUser { eamil } }\\n ^\", \"traceSpan\" : { ... }, \"uri\" : \"/api/graphql\" } Where code is the HTTP status code. HTTP error codes ranging from 400-499 indicate client-side errors, while the HTTP error codes ranging from 500-599 are server-side errors. More information on error codes and their meaning is available at httpstatuses.com . message field contains a human-readable explanation of the issue the query has encountered.","title":"Malformed query"},{"location":"api/errors/#erroneous-query","text":"A query is erroneous if it cannot be successfully completed by the server, due to either the server malfunction or a client-side error. For example, a query that looks up a non-existing object qualifies as erroneous. The following query is looking for the status of an awsNativeAccount object whose Rubrik ID is the value indicated by the awsNativeAccountRubrikId argument. In this example, the Rubrik ID is a randomly generated UUID that does not represent a valid AWS Native account. { \"query\": \"query { awsNativeAccount( awsNativeAccountRubrikId: \\\"7f86b446-dfee-44c5-9a1e-52a7b92b0ab3\\\", awsNativeProtectionFeature: EC2) { status } }\" } The Rubrik API server responds with an HTTP status code of 200 OK. The response body looks as follows: { \"data\" : null, \"errors\" : [ { \"extensions\" : { \"code\" : 403, \"trace\" : { ... } }, \"locations\" : [ { \"column\" : 9, \"line\" : 1 } ], \"message\" : \"Objects are not authorized\", \"path\" : [ \"awsNativeAccount\" ] } ] } Where: \"data\" : null indicates that the actual response is absent. (The data field contains the actual response body as seen when issuing a successful query.) \"errors\" contains a list of errors that occurred during the processing of the query. \"errors.extensions.code\" is the HTTP error code. \"errors.extensions.message\" is a human-readable error message.","title":"Erroneous query"},{"location":"api/errors/#summary","text":"To summarize, the following algorithm can be used when establishing whether a query is successful: If the HTTP error code is equal to or greater than 400, the query failed. If errors field in response JSON is populated, the query failed. Otherwise, the query is successful, and its results are in data field.","title":"Summary"},{"location":"api/playground/","text":"GraphQL Playground Running sample queries against Rubrik GraphQL API is an essential part of building and debugging integration code. A number of tools are available that facilitate query execution and schema exploration. One such tool is Apollo Client Devtools Chrome extension. Download the extension and add it to Chrome. Log in to the Rubrik application. Open Developer Tools . Find Apollo tab ( Elements , Console , Sources , ..., Apollo ). On the left, there is a list of all queries executed by the current page. Select a query and click Run in GraphiQL . GraphiQL allows you to execute arbitrary queries, aiding query authoring with code completion. Docs button in the top, right corner opens a Documentation Explorer, allowing for easy schema exploration. Warning Any mutation issued through Apollo client will result in the modification of real data in your account. Be careful when experimenting with mutations!","title":"Playground"},{"location":"api/playground/#graphql-playground","text":"Running sample queries against Rubrik GraphQL API is an essential part of building and debugging integration code. A number of tools are available that facilitate query execution and schema exploration. One such tool is Apollo Client Devtools Chrome extension. Download the extension and add it to Chrome. Log in to the Rubrik application. Open Developer Tools . Find Apollo tab ( Elements , Console , Sources , ..., Apollo ). On the left, there is a list of all queries executed by the current page. Select a query and click Run in GraphiQL . GraphiQL allows you to execute arbitrary queries, aiding query authoring with code completion. Docs button in the top, right corner opens a Documentation Explorer, allowing for easy schema exploration. Warning Any mutation issued through Apollo client will result in the modification of real data in your account. Be careful when experimenting with mutations!","title":"GraphQL Playground"},{"location":"api/rate_limiting/","text":"Rate-limiting GraphQL API requests Rate-limiting refers to restricting the number of requests that an API can service in a specified unit of time. For large-scale dsitributed systems, rate-limiting is essential to protect the API services and resources from excessive use and to maintain service availability for all clients at all times. Rubrik enforces rate-limiting at the GraphQL API service level as well as at the client level. HTTP 429 - Too many requests The Rubrik GraphQL API service rejects the incoming requests and responds with the HTTP 429 - Too many requests error when the number of incoming requests per second exceeds the limit imposed by the API service. When this happens, reduce the number of requests per second and retry the failed requests.","title":"Rate-limiting"},{"location":"api/rate_limiting/#rate-limiting-graphql-api-requests","text":"Rate-limiting refers to restricting the number of requests that an API can service in a specified unit of time. For large-scale dsitributed systems, rate-limiting is essential to protect the API services and resources from excessive use and to maintain service availability for all clients at all times. Rubrik enforces rate-limiting at the GraphQL API service level as well as at the client level.","title":"Rate-limiting GraphQL API requests"},{"location":"api/rate_limiting/#http-429-too-many-requests","text":"The Rubrik GraphQL API service rejects the incoming requests and responds with the HTTP 429 - Too many requests error when the number of incoming requests per second exceeds the limit imposed by the API service. When this happens, reduce the number of requests per second and retry the failed requests.","title":"HTTP 429 - Too many requests"},{"location":"reference/","text":"function stuff() { var el = document.getElementsByClassName(\"col-md-3\")[0]; el.parentNode.removeChild(el); var page = document.getElementsByClassName(\"col-md-9\")[0]; page.className=\"col-md-12\"; } stuff();","title":"Reference"},{"location":"use-cases/template/","text":"Use Case Template Don't forget to add the new page to navigation in mkdocs.yml ! API area name (eg. VMware) Overview of the functionality offered by Polaris APIs for this area. Sub-area When needed. Brief overview of the sub-area. The following sections should contain an explanation of the action being performed and ready-to-execute command-line example that matches the explanation. Retrieving Adding Modifying Removing Additional operations when makes sense Another sub-area A template command-line example: QUERY='{ \"query\": \"query { currentUser { email roles { name } } }\" }' curl -X POST https://account.rubrik.com/api/graphql \\ --header \"authorization: Bearer ...\" \\ --header \"content-type: application/json\" \\ --data \"$(echo $QUERY)\"","title":"Use Case Template"},{"location":"use-cases/template/#use-case-template","text":"Don't forget to add the new page to navigation in mkdocs.yml !","title":"Use Case Template"},{"location":"use-cases/template/#api-area-name-eg-vmware","text":"Overview of the functionality offered by Polaris APIs for this area.","title":"API area name (eg. VMware)"},{"location":"use-cases/template/#sub-area","text":"When needed. Brief overview of the sub-area. The following sections should contain an explanation of the action being performed and ready-to-execute command-line example that matches the explanation.","title":"Sub-area"},{"location":"use-cases/template/#retrieving","text":"","title":"Retrieving"},{"location":"use-cases/template/#adding","text":"","title":"Adding"},{"location":"use-cases/template/#modifying","text":"","title":"Modifying"},{"location":"use-cases/template/#removing","text":"","title":"Removing"},{"location":"use-cases/template/#additional-operations-when-makes-sense","text":"","title":"Additional operations when makes sense"},{"location":"use-cases/template/#another-sub-area","text":"A template command-line example: QUERY='{ \"query\": \"query { currentUser { email roles { name } } }\" }' curl -X POST https://account.rubrik.com/api/graphql \\ --header \"authorization: Bearer ...\" \\ --header \"content-type: application/json\" \\ --data \"$(echo $QUERY)\"","title":"Another sub-area"}]}